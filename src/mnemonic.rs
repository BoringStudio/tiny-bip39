use bitreader::BitReader;

use data_encoding::HEXUPPER;

use util::{truncate, checksum, BitWriter};
use crypto::{gen_random_bytes, sha256};
use error::{ErrorKind, Result};
use mnemonic_type::MnemonicType;
use language::Language;

/// The primary type in this crate, most tasks require creating or using one.
///
/// To create a *new* [`Mnemonic`][Mnemonic] from a randomly generated key, call [`Mnemonic::new()`][Mnemonic::new()].
///
/// To get a [`Mnemonic`][Mnemonic] instance for an existing mnemonic phrase, including
/// those generated by other software or hardware wallets, use [`Mnemonic::from_phrase()`][Mnemonic::from_phrase()].
///
/// You can get the HD wallet [`Seed`][Seed] from a [`Mnemonic`][Mnemonic] by calling [`Mnemonic::get_seed()`][Mnemonic::get_seed()],
/// from there you can either get the raw byte value with [`Seed::as_bytes()`][Seed::as_bytes()], or the hex
/// representation with [`Seed::as_hex()`][Seed::as_hex()].
///
/// You can also get the original entropy value back from a [`Mnemonic`][Mnemonic] with [`Mnemonic::to_entropy()`][Mnemonic::to_entropy()],
/// but beware that the entropy value is **not the same thing** as an HD wallet seed, and should
/// *never* be used that way.
///
///
/// [Mnemonic]: ./mnemonic/struct.Mnemonic.html
/// [Mnemonic::new()]: ./mnemonic/struct.Mnemonic.html#method.new
/// [Mnemonic::from_phrase()]: ./mnemonic/struct.Mnemonic.html#method.from_phrase
/// [Mnemonic::get_seed()]: ./mnemonic/struct.Mnemonic.html#method.get_seed
/// [Mnemonic::to_entropy()]: ./mnemonic/struct.Mnemonic.html#method.to_entropy
/// [Seed]: ./seed/struct.Seed.html
/// [Seed::as_bytes()]: ./seed/struct.Seed.html#method.as_bytes
/// [Seed::as_hex()]: ./seed/struct.Seed.html#method.as_hex
///
#[derive(Debug, Clone)]
pub struct Mnemonic {
    phrase: String,
    lang: Language,
    entropy: Vec<u8>,
}

impl Mnemonic {
    /// Generates a new `Mnemonic`
    ///
    /// Can be used to get the [`Seed`][Seed] using [`Mnemonic::get_seed()`][Mnemonic::get_seed()].
    ///
    /// Can also be used to get the original entropy value. Use [`Mnemonic::as_entropy()`][Mnemonic::as_entropy()] for a slice, or
    /// [Mnemonic::get_entropy()][Mnemonic::get_entropy()] for an owned `Vec<u8>`.
    ///
    ///
    /// # Example
    ///
    /// ```
    /// use bip39::{Mnemonic, MnemonicType, Language, Seed};
    ///
    /// let mnemonic_type = MnemonicType::Words12;
    ///
    /// let mnemonic = Mnemonic::new(mnemonic_type, Language::English);
    ///
    /// println!("phrase: {}", mnemonic.phrase());
    ///
    /// let seed = Seed::new(&mnemonic, "");
    /// let seed_bytes: &[u8] = seed.as_bytes();
    /// let seed_hex: String = seed.to_hex();
    ///
    /// assert_eq!(seed_bytes.len(), 64);
    /// ```
    pub fn new(mnemonic_type: MnemonicType, lang: Language) -> Mnemonic {
        let entropy_bits = mnemonic_type.entropy_bits();

        let entropy = gen_random_bytes(entropy_bits / 8);

        Mnemonic::from_entropy_unchecked(&entropy, mnemonic_type, lang)
    }

    /// Create a [`Mnemonic`][Mnemonic] from generated entropy
    ///
    /// # Example
    ///
    /// ```
    /// use bip39::{Mnemonic, MnemonicType, Language};
    ///
    /// let entropy = &[0x33, 0xE4, 0x6B, 0xB1, 0x3A, 0x74, 0x6E, 0xA4, 0x1C, 0xDD, 0xE4, 0x5C, 0x90, 0x84, 0x6A, 0x79];
    /// let mnemonic = Mnemonic::from_entropy(entropy, MnemonicType::for_key_size(128).unwrap(), Language::English).unwrap();
    ///
    /// assert_eq!("crop cash unable insane eight faith inflict route frame loud box vibrant", mnemonic.phrase());
    /// ```
    ///
    /// [Mnemonic]: ../mnemonic/struct.Mnemonic.html
    pub fn from_entropy(entropy: &[u8],
                        mnemonic_type: MnemonicType,
                        lang: Language) -> Result<Mnemonic> {
        let entropy_length_bits = entropy.len() * 8;

        if entropy_length_bits != mnemonic_type.entropy_bits() {
            bail!(ErrorKind::InvalidEntropyLength(entropy_length_bits, mnemonic_type));
        }

        let mnemonic = Self::from_entropy_unchecked(entropy, mnemonic_type, lang);

        Ok(mnemonic)
    }

    fn from_entropy_unchecked(entropy: &[u8],
                              mnemonic_type: MnemonicType,
                              lang: Language) -> Mnemonic {
        let word_count = mnemonic_type.word_count();
        let word_list = lang.get_wordlist();

        let entropy_hash = sha256(entropy);

        // We put both the entropy and the first byte of the hash of the entropy (in that order)
        // into a single Vec. Then just read 11 bits at a time out of the entire thing `word_count`
        // times. We can do that because:
        //
        // 12 words * 11bits = 132bits
        // 15 words * 11bits = 165bits
        // ...
        //
        // It grabs the entropy and then the right number of hash bits, up to 8, no more.

        let mut combined = Vec::with_capacity(entropy.len() + 1);

        combined.extend_from_slice(entropy);
        combined.push(entropy_hash.as_ref()[0]);

        let phrase = {
            let mut reader = BitReader::new(&combined);
            let mut phrase = String::with_capacity(128);

            let n = reader.read_u16(11).expect("We are guaranteed to have enough bits to read; qed");
            phrase.push_str(word_list[n as usize]);

            for _ in 1..word_count {
                let n = reader.read_u16(11).expect("We are guaranteed to have enough bits to read; qed");
                phrase.push(' ');
                phrase.push_str(word_list[n as usize]);
            }

            phrase
        };

        let entropy = truncate(combined, entropy.len());

        Mnemonic {
            phrase,
            lang,
            entropy
        }
    }

    /// Create a [`Mnemonic`][Mnemonic] from generated entropy hexadecimal representation
    ///
    /// # Example
    ///
    /// ```
    /// use bip39::{Mnemonic, MnemonicType, Language};
    ///
    /// let entropy = "33E46BB13A746EA41CDDE45C90846A79";
    /// let mnemonic = Mnemonic::from_entropy_hex(entropy, MnemonicType::for_key_size(128).unwrap(), Language::English).unwrap();
    ///
    /// assert_eq!("crop cash unable insane eight faith inflict route frame loud box vibrant", mnemonic.phrase());
    /// ```
    ///
    /// [Mnemonic]: ../mnemonic/struct.Mnemonic.html
    pub fn from_entropy_hex(entropy: &str,
                           mnemonic_type: MnemonicType,
                           lang: Language) -> Result<Mnemonic> {

        Mnemonic::from_entropy(&HEXUPPER.decode(entropy.as_ref())?, mnemonic_type, lang)
    }

    /// Create a [`Mnemonic`][Mnemonic] from an existing mnemonic phrase
    ///
    /// The phrase supplied will be checked for word length and validated according to the checksum
    /// specified in BIP0039
    ///
    /// # Example
    ///
    /// ```
    /// use bip39::{Mnemonic, Language};
    ///
    /// let phrase = "park remain person kitchen mule spell knee armed position rail grid ankle";
    ///
    /// let mnemonic = Mnemonic::from_phrase(phrase, Language::English).unwrap();
    /// ```
    ///
    /// [Mnemonic]: ../mnemonic/struct.Mnemonic.html
    pub fn from_phrase<S>(phrase: S, lang: Language) -> Result<Mnemonic>
        where S: Into<String>
    {
        let phrase = phrase.into();

        // this also validates the checksum and phrase length before returning the entropy so we
        // can store it. We don't use the validate function here to avoid having a public API that
        // takes a phrase string and returns the entropy directly. See the Mnemonic::entropy()
        // docs for the reason.
        let entropy = Mnemonic::phrase_to_entropy(&phrase, lang)?;

        let mnemonic = Mnemonic {
            phrase,
            lang,
            entropy,
        };

        Ok(mnemonic)
    }

    /// Validate a mnemonic phrase
    ///
    /// The phrase supplied will be checked for word length and validated according to the checksum
    /// specified in BIP0039
    ///
    /// Note: you cannot use this function to determine anything more than whether the mnemonic
    /// phrase itself is intact, it does not check the password or compute the seed value. For that,
    /// you should use [`Mnemonic::from_phrase()`][Mnemonic::from_phrase()].
    ///
    /// # Example
    ///
    /// ```
    /// use bip39::{Mnemonic, Language};
    ///
    /// let test_mnemonic = "park remain person kitchen mule spell knee armed position rail grid ankle";
    ///
    /// match Mnemonic::validate(test_mnemonic, Language::English) {
    ///     Ok(_) => { println!("valid: {}", test_mnemonic); },
    ///     Err(e) => { println!("e: {}", e); return }
    /// }
    /// ```
    ///
    /// [Mnemonic::from_phrase()]: ../mnemonic/struct.Mnemonic.html#method.from_phrase
    pub fn validate(phrase: &str, lang: Language) -> Result<()> {
        Mnemonic::phrase_to_entropy(phrase, lang)?;

        Ok(())
    }

    /// Calculate the checksum, verify it and return the entropy
    ///
    /// Only intended for internal use, as returning a `Vec<u8>` that looks a bit like it could be
    /// used as the seed is likely to cause problems for someone eventually. All the other functions
    /// that return something like that are explicit about what it is and what to use it for.
    fn phrase_to_entropy(phrase: &str, lang: Language) -> Result<Vec<u8>> {
        let mnemonic_type = MnemonicType::for_phrase(phrase)?;
        let entropy_bits = mnemonic_type.entropy_bits();
        let checksum_bits = mnemonic_type.checksum_bits();
        let total_bits = mnemonic_type.total_bits();

        let wordmap = lang.get_wordmap();

        let mut to_validate = BitWriter::with_capacity(total_bits);

        for word in phrase.split(" ") {
            let mut n = match wordmap.get(&word) {
                Some(n) => *n,
                None => bail!(ErrorKind::InvalidWord)
            };

            to_validate.push(n, 11);
        }

        assert!(to_validate.len() == total_bits, "Insufficient amount of bits to validate");

        let to_validate = to_validate.into_bytes();
        let entropy_bytes = entropy_bits / 8;

        let checksum_to_validate = checksum(to_validate[entropy_bytes], checksum_bits);
        let entropy = truncate(to_validate, entropy_bytes);
        let hash = sha256(&entropy);
        let new_checksum = checksum(hash.as_ref()[0], checksum_bits);

        if new_checksum != checksum_to_validate {
            bail!(ErrorKind::InvalidChecksum)
        }

        Ok(entropy)
    }

    /// Get the mnemonic phrase as a string reference
    pub fn phrase(&self) -> &str {
        &self.phrase
    }

    /// Get the original entropy value of the mnemonic phrase as a slice
    ///
    /// # Example
    ///
    /// ```
    /// use bip39::{Mnemonic, Language};
    ///
    /// let phrase = "park remain person kitchen mule spell knee armed position rail grid ankle";
    ///
    /// let mnemonic = Mnemonic::from_phrase(phrase, Language::English).unwrap();
    ///
    /// let entropy: &[u8] = mnemonic.entropy();
    /// ```
    pub fn entropy(&self) -> &[u8] {
        &self.entropy
    }

    /// Get the [`Language`][Language]
    ///
    /// [Language]: ../language/struct.Language.html
    pub fn language(&self) -> Language {
        self.lang
    }

    /// Get the original entropy used to create the Mnemonic as a hex string
    ///
    /// Note: this allocates a new String
    pub fn entropy_hex(&self) -> String {
        HEXUPPER.encode(&self.entropy)
    }
}

impl AsRef<str> for Mnemonic {
    fn as_ref(&self) -> &str {
        self.phrase()
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn new_same_as_from_phrase() {
        let m1 = Mnemonic::new(MnemonicType::Words12, Language::English);
        let m2 = Mnemonic::from_phrase(m1.phrase(), Language::English).unwrap();

        assert_eq!(m1.entropy(), m2.entropy(), "Entropy must be the same");
    }
}
